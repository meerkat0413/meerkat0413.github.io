[{"categories":["note"],"content":"chapter 0:historical prospective mainframe system  slow I/O device:card reader/printer evolution  batch → multi-programming → time-shared   batch drawback  one jot at a time no interaction between users and jobs CPU is often idle  I/O speed « CPU speed(at least 1:1000)     multi-programming system 以系統為角度  overlap the I/O and computation of jobs spooling(simultaneous peripheral operation on-line)  I/O is done with no CPU intervention CPU just needs to be notified when I/O is done     time-sharing system(multi-tasking system) 以人為角度  an interactive system provide direct communication bewteen the users and system multiple users can share thecomputer simultaneouly switch job when  finish wait I/O a short peroid of time       computer system architecture  parallel systems  symmetic multiprocessor system (SMP)  each processor runs the same OS most popular multiple-processor architecture   Asymmetric multiporcessor system  each porcessor is assigned a spectific task more common in extremly large systems     multi core processor 單一的processor  A CPU with multiple cores on the same die(chip)    many-core processor 可以到百個core 單一的processor  GPU  single instruction multiple data 同時間只能做一個指令     special-purpose systems  real-time operating system  real time doesn’t mean speed but keeping deadlines real-time requirement :hard or soft  soft real-time requirements 盡量完成、達到使用者的滿意度 hard real-time requirements 無hard disk         chapter 1:introduction  controls and coordinates the use of the hardware/resources is the “permanent” software that control/abstracts hardware resources for user applications  interrupt  modern OS are interrupt driven(event driven) the ocurrence of an event is signaled by an interrupt from either hardware and software  hardware may trigger an interrupt at any time by sending a signal to CPU 被動、可以被handle的signal是固定的數量(已燒好)  software may trigger an interrupt either by an error(ex:segment fault) or by user request for an operating system service(sytem call) ,also called trap 主動、可有多個systemcall     storage-device hierarchy  main mermory-only large storage media that CPU can access directly  RAM   secondary storage-extension of main memory that provides large nonvolatile storage(斷電資料不會消失)  magnetic disk   caching  information in use copied form slower to faster storage temporarily    hardware protection dual-mode operation  sharing system resources requires OS to ensure that an incorrect program cannot cause other programs to execute incorrectly   user mode-execution done on behalf of user monitor mode(also kernel mode or system mode)-execution done on behalf of operation system   mode bit added to computer hardware to indicate the current mode:kernel(0) or user(1) privileged instructions  executed only in monitor mode requested by users(system call)    I/O protection  all I/O instructions are priviledged instructions  memory protection  protect  interrupt vector and the interrupt service routines data access and over-write from other programs    CPU protection  prevent user program from not returning control  getting stuck in an infinite loop   HW support:timer-interrupts computer after specified period   chapter 2:OS OS Structure - OS Services  user interface  CLI  shell:command-line interpreter(CSHELL,BASH)  adjusted according to user behavior and preference     GUI   communication  communication may take place using either message passing(memory copy need system call to copy) or shared memory(need system call to create memory)    OS Application Interface  system calls  request OS services an explicit request to the kernel made via a software interrupt gernerally available as assembly-language instructions   API 透過API去呼叫system call  user mostly program against API instead of system call commonly implemented by language libraries,ex:C library an API could involve zero or multiple system call  both malloc() and free() use system brk() math API functions,such as abs(),don’t need to involve system call the most common API  POSIX API for POSIX-based systems(include virtually all versions of UNIX,Linux,and Mac OS X)         OS structure  layer OS Microkernel OS kernel變很小，因此有很多module(容易替換)跑在user space，kernel只要負責module之間的溝通，但因為多了許多msg copy速度變很慢 Modular OS 將module化的放在kernel space較有效率   chapter 3:Processed Concept  active entity:a program in execution in memory a process include:  code segment data section-global variables stack-temporary local variables and functions heap-dymabic allocated variables or classes current activity(program counter,register contents) a set of associated resources(ex:open file handlers)     chapter 4:Multithreaded Progrmming  chapter 5:Porcess Scheduling  chapter 6:Process Synchronization  chapter 7:Deadlocks  chapter 8:Memory Management  chapter 9:Virtual Memory Menagement  chapter 10:File System Interface  chapter 11:File System Implementation  chapter 12:Mass Storage System  chapter 13:I/O Systems referenece http://ocw.nthu.edu.tw/ocw/index.php?page=course\u0026cid=141\u0026 ","description":"","tags":["os"],"title":"Os_note","uri":"/posts/os_note/"},{"categories":null,"content":" font: google font ,img: unsplash,icon: font awesome icon sass :可以用變數的方式寫css，易管理CSS  ","description":"","tags":null,"title":"Web_note","uri":"/posts/web_note/"},{"categories":["note"],"content":"UNIX damain socket說明  可讓同一台主機上的行程互相通信，允許在行程間傳輸案描述符，讓process 可以開啟檔案，使原先無法存取該檔案的process可以用 有stream 與 datagram socket 的用法，由於 UNIX domain socket 的datagram傳送是在核心內部進行，因此是可靠的，全部的訊息都會依序傳遞，而且不會重覆，使用datagram socket 通信不可靠清況是透過網路傳輸datagram的情況(UDP) 不需透過網路protocol 類似於TCP和UDP 例子: X window伺服器和GUI程式之間的通訊  Internet domain socket  可讓不同主機的應用程式透過TCP/IP網路進行通信，datagram socket採用UDP(User Datagram Protocol)，而stream socket通常使用TCP(Transmission Control Protocol) 也可以用於同一台主機的通訊  socket domain 用法    Domain 通信方式 應用程式間的通信 位址格式 位址結構     AF_UNIX 在核心內 在同一台主機 路徑名稱 sockaddr_un   AF_INET 透過IPv4 透過IPv4網路相連的主機 32位元IPv4位址與16位元的port number sockaddr_in   AF_INET6 透過IPv6 透過IPv6網路相連的主機 128位元IPv6位址與16位元的port number sockaddr_in6   AF_UNSPEC 允許IPv4、IPv6       PF_INET vs AF_INET RCP/IP起初設計時，認為不同的protocol會有多個不同的address形式，所以有了PF(protocol family)和AF(address family)，建立socket用pf而bind/connect則用af，但一個PF只有一個AF因此就混用\n","description":"","tags":["linux","socket","IPC"],"title":"socket","uri":"/posts/socket/"},{"categories":["note"],"content":")\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  int main() { int var = 123; // pointer for var  int *ptr1; // double pointer for ptr2  int **ptr2; // storing address of var in ptr2  ptr1 = \u0026var; // Storing address of ptr1 in ptr2  ptr2 = \u0026ptr1; // Displaying value of var using  // both single and double pointers  printf(\"Value of var = %d\\n\", var ); printf(\"Value of var using single pointer = %d\\n\", *ptr1 ); printf(\"Value of var using double pointer = %d\\n\", **ptr2); printf(\"Address of var = %p\\n\", \u0026var); printf(\"value of ptr1 = %p\\n\", ptr1); printf(\"Address of ptr1 = %p\\n\", \u0026ptr1); printf(\"value of ptr1 = %p\\n\", ptr1); return 0; }   output:\nValue of var = 5 Value of var using single pointer = 5 Value of var using double pointer = 5 Address of var = 0x7fff19c18564 value of ptr1 = 0x7fff19c18564 Address of ptr1 = 0x7fff19c18568 value of ptr2 = 0x7fff19c18568 Address of ptr2 = 0x7fff19c18570 value of *ptr2 = 0x7fff19c18564 value of **ptr2 = 5 value of *ptr1 = 5 ","description":"","tags":["c"],"title":"Pointer","uri":"/posts/pointer/"},{"categories":["note"],"content":"使用flock()將整個檔案上鎖  只能對整個檔案上鎖 只能產生勸告鎖(access 文件前，先檢查鎖，此時鎖才發揮作用，若硬要讀寫，則勸告鎖無作用)  1 2 3 4 5 6  #include \u003csys/file.h\u003eint open(file,mode); int flock(int fd,int operation,int mode) //operation:LOCK_SH、  //LOCK_EX、  //LOCK_UN、  //LOCK_NB(enum)    參數  LOCK_SH:多個process可持有 LOCK_EX:只有一個process可持有 LOCK_NB:非阻塞式的上鎖請求(預設為blocking) LOCK_UN:解鎖   相容性     process LOCK_SH(B) LOCK_EX(B)     LOCK_SH(A) yes no   LOCK_EX(A) no no     check lock cat /proc/locks  FLOCK為flock()建立的鎖，POSIX是fcntl()建立的鎖 鎖分為ADVISORY和MANDATORY    ","description":"","tags":["linux","mutex","filelock"],"title":"File_locking","uri":"/posts/file_locking/"},{"categories":["note"],"content":"git git 從無到有 git remote repository  在git server 上新增資料夾 mkdir /home/itri/git/www.git git init --bare  git local repository  在新增成git repository git init 撰寫ignore檔 vi .gitignore first commit git add . git commit -m 'first import' 同步remote端repository git remote add origin itri@10.101.129.43:/home/itri/git/www.git push git push origin master   git merge one version  git add xxxxx git commit -m “…” [branch1] git push origin [branch1] git pull origin dev fix conflict git commit -am “fix conflict” git checkout dev git merge [branch1] git -d [branch1]  another version  git checkout branch “issue” git commit git checkout master git pull origin master git merge issue   git pull remote branch  git fetch origin git checkout –track origin/\u003cremote_branch_name\u003e(new local branch and track the remote branch)   doesn’t have enough permission(object 的概念) 可參考解說 https://github.com/doggy8088/Learn-Git-in-30-days/blob/master/zh-tw/06.md 此 git push錯誤表示，它沒有足夠的權限增加新的object到當下repository的objects目錄下，因此到.git/object中ls -al就會看到git的objects文件夾下的某些目錄由其他人擁有\n$ ls -l objects\rdrwxr-xr-x 2 tom git 4096 Oct 8 2016 01\rdrwxr-xr-x 2 tom git 4096 Oct 8 2016 02\rdrwxr-xr-x 2 amy amy 4096 Oct 8 2016 03\rdrwxr-xr-x 2 amy amy 4096 May 1 2017 04\rdrwxr-xr-x 2 tom git 4096 May 1 2017 05\rdrwxr-xr-x 2 tom git 4096 May 6 2017 06\rSet the Appropriate Permissions on Objects Directory 為解決此問題，要確保該用戶和組具有對該目錄的讀寫權限\ncd /your/git/repo\rchgrp -R git objects\rchmod -R g+rws objects\r 確保所有需要訪問git的用戶都屬於git組。將上述chgrp命令中的“ git”更改為所有開發人員所屬的組。 “ g + rws”中的“ s”選項用於設置對象文件夾中的setuid位。這將確保在objects文件夾下創建的任何新目錄都將成為git group擁有的objects文件夾中的組名。  Share the Git Repository with a Group  即使執行了上述操作之後，相同的問題仍可能再次出現，並且只要出現問題，都可能必須執行上述的chgrp和chmod。 在這種情況下，未將git存儲庫（例如：myproj）設置為組的共享repositor，它可能只是一個bare repository。 要驗證repository是否已設置用於組共享，請在有問題的git存儲庫中執行git config -l，若沒看到 “core.sharedrepository”表示為非共享，轉換方式git config core.sharedRepository group(不用替換字)，再輸入git config -l確認是否更改，另外也可在config中看到sharedrepository = 2   常見問題 修改commit後的作者資訊(未push前) git commit --amend --author=\"usrname \u003cemail\u003e\" --no-edit\n","description":"","tags":["git","linux"],"title":"git note","uri":"/posts/git_note/"},{"categories":["note"],"content":"實作筆記   linux 解壓縮\n  make file 筆記\n https://wwssllabcd.github.io/blog/2016/10/03/how-to-write-make-file/    佔有linux空間查詢\n du -B M --max-depth=1 | sort -g    Enforce Return After Callback\n  ssh without password\n https://xenby.com/b/220-%e6%95%99%e5%ad%b8-%e7%94%a2%e7%94%9fssh-key%e4%b8%a6%e4%b8%94%e9%80%8f%e9%81%8ekey%e9%80%b2%e8%a1%8c%e5%85%8d%e5%af%86%e7%a2%bc%e7%99%bb%e5%85%a5 https://code.visualstudio.com/docs/remote/troubleshooting local generate key–\u003epub key copy to remote host –\u003e chmod dir .ssh to 700 and file authorized_keys to 600(optional chown)    vscode remote development config  #防止timeout，每120秒就向server發送keep-alive封包，超過60次無回應斷線 ServerAliveInterval 120 ServerAliveCountMax 60    vscode 寫code好用工具\n  tmux setting\n shell: tmux source-file ~/.tmux.conf    Saving a read-only file edited in vi / vim\n  https://blog.niclin.tw/2018/08/19/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E8%A9%B2%E7%9F%A5%E9%81%93%E7%9A%84-c10k-%E5%95%8F%E9%A1%8C/\n  ftp server install –\u003ehttps://hackmd.io/@uNmR8bp1S62yvV_R6zJQng/SycNmIWG8\n  若無法裝wireshark，可用tcpdump 抓封包，並存成file，再由wireshark打開 tcpdump -i eth0 -w test.pcap\n  更改route sudo route del -net 0.0.0.0 gw 192.168.178.1 netmask 0.0.0.0 dev eth0\n  lib version dpkg -l | grep libxxx   比bash好看的shell\n  Ubuntu 安裝 zsh：\r前置準備，需要先安裝下列的套件：\rsudo apt-get install wget curl git\rInstalling Zsh:\rsudo apt install zsh\r修改預設的 shell 為 zsh:\rchsh -s $(which zsh)\r檢查目前使用中的 shell:\recho $SHELL\rInstall Oh-my-Zsh:\rsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\r auto build tools python watchdog.observable 監看檔案狀態，若未加sleep執行檔無執行權限，使用方式:   建資料夾，新增auto_build.py檔 複製以下文字至auto_build.py install watchdog:pip install watchdog 執行 python auto_build.py 若監看的file有更動，會執行os.system中的動作  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  import time from watchdog.observers import Observer from watchdog.events import FileSystemEventHandler import os import sys pattern = [\".h\", \".c\"] class Handler(FileSystemEventHandler): def on_modified(self, event): for p in pattern: if event.src_path.endswith(p): os.system(\"cd ../;make clean \u0026\u0026 make \u0026\u0026 cd build/x86-64-debug; sleep 1 \u0026\u0026 ./group\") #fix here if __name__ == \"__main__\": path = sys.argv[1] if len(sys.argv) \u003e 1 else '../' print 'monitor path: ', path #fix here print 'build path: ', path + 'build/x86-64-debug' #fix here event_handler = Handler() observer = Observer() observer.schedule(event_handler, path=path, recursive=True) observer.start() try: while True: time.sleep(1) except KeyboardInterrupt: observer.stop() observer.join()    add route route add 140.96.0.0 mask 255.255.0.0 10.101.129.13 route add 10.21.0.0 mask 255.255.0.0 10.101.129.13  tags: linux ftp tcpdump tmux vscode note javascript make file ","description":"","tags":["linux","ftp","tcpdump","tmux","vscode","javascript","Makefile"],"title":"實作筆記","uri":"/posts/%E5%AF%A6%E4%BD%9C%E7%AD%86%E8%A8%98/"},{"categories":["note"],"content":"mysql 存取   搜尋某欄位所有的唯一值 SELECT DISTINCT mycolumn FROM mytable\n  總計(sum、count、average)搜尋結果 SELECT SUM(mycolumn) FROM mytable\n  秀出所有欄位資訊 SHOW COLUMNS FROM my_table;\n  搜尋特定時間欄位 SELECT *\rFROM events\rWHERE event_date BETWEEN date_sub(now(), interval 1 week) AND date_add(now(), interval 3 day); https://popsql.com/learn-sql/mysql/how-to-query-date-and-time-in-mysql/\n  複製db\n mysqldump -u root -p source_db \u003e d:\\db\\source_db.sql mysql -u root -p destination_db \u003c d:\\db\\source_db.sql    連線數量查詢(default 100) mysql\u003e show variables like 'max_connections';\n  trace “too many connection” problem\n use mytop tool    tags: linux mysql ","description":"","tags":["mysql","linux"],"title":"mysql note","uri":"/posts/mysql_note/"},{"categories":["note"],"content":" source code  preprocess gcc -o pre.c -E test.c 原始碼(已處理) ex:pre.c  compiler gcc -o test.s -S pre.c 組合語言 ex:test.s  assembler gcc -o test.o -c test.s machine code ex:test.o  linker gcc -o test test.o 執行檔 test    tags: linux C/C++ compiler `\n","description":"","tags":["linux","C/C++"],"title":"程式編譯流程","uri":"/posts/%E7%A8%8B%E5%BC%8F%E7%B7%A8%E8%AD%AF%E6%B5%81%E7%A8%8B/"},{"categories":["note"],"content":"GitStats  sudo apt-get install gitstats gitstats [git control dir] [output dir] ex:gitstats repo gen python -m SimpleHTTPServer 8080 or 至 [output dir]中打開 index.html  結果如下: gitinspector  npm i -g gitinspector 至project下輸入 gitinspector --format=html --timeline --localize-output -w .\u003e gitresult.html   tags: git ","description":"","tags":["git"],"title":"Generating statistics from Git repository","uri":"/posts/generating_statistics_from_git_repository/"},{"categories":["note"],"content":"Q1:ssl封包看不到 Answer:\n Edit \u003e Preferences \u003e Protocols \u003e TCP \u003e Analyze TCP sequence numbers Edit \u003e Preferences \u003e Protocols \u003e HTTP \u003e SSL/TLS Ports:[ex:5000]  tags: wireshark ","description":"","tags":["wireshark"],"title":"Wireshark note","uri":"/posts/wireshark_note/"},{"categories":["note"],"content":"Permission denied (publickey) because of sync  由於synced_folder錯誤，導致無法正常登入  ex: config.vm.synced_folder '.', '/home/vagrant/' 因為configure會覆蓋vm上的主目錄並破壞vm上的.ssh設置，因此改為\nconfig.vm.synced_folder '.', '/home/vagrant/foo foo為空目錄 How to assign unique ssh port config.vm.network :forwarded_port, guest: 22, host: 3200, id: 'ssh'\nreference  https://gist.github.com/pastleo/ab1255846b5335407105 https://medium.com/@ganpat.bit/how-to-modify-vagrant-vms-default-ssh-port-d3e996d07be2  tags: vagrant ","description":"","tags":["vagrant"],"title":"vagrant 筆記","uri":"/posts/vagrant_note/"}]
